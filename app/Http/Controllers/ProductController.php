<?php

namespace App\Http\Controllers;

use App\Models\Product;
use Illuminate\Http\Request;
use Illuminate\Routing\Controller as BaseController;
use App\Models\Notification;
use App\Http\Controllers\StockController;
use App\Http\Controllers\SaleController;
use App\Models\Stock;
use App\Models\StockDeposit;
use App\Models\Sale;
use App\Models\SaleProduct;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Carbon;


class ProductController extends BaseController
{
    public function index()
    {
        $products = Product::all();
        return view('products.index', compact('products'));
    }

    public function create()
    {
        return view('products.create');
    }


    public function store(Request $request)
    {
        // Valeur par d√©faut √† 0 si non envoy√©e
        $request->merge([
            'is_depositable' => $request->input('is_depositable', 0),
        ]);

        $data = $request->validate([
            'name' => 'required|string',
            'purchase_price' => 'required|numeric',
            'price_detail' => 'nullable|numeric',
            'price_semi_bulk' => 'nullable|numeric',
            'price_bulk' => 'nullable|numeric',
            'quantity' => 'required|numeric',
            'is_depositable' => 'required|integer',
            'deposit_price' => 'nullable|numeric',
            'filling_price' => 'nullable|numeric',
        ]);

        try {
            // Gestion des champs selon le type
            if ($data['is_depositable']) {
                $data['price_detail'] = null;
                $data['price_semi_bulk'] = null;
                $data['price_bulk'] = null;
            } else {
                $data['deposit_price'] = null;
                $data['filling_price'] = null;
            }

            // Cr√©ation du produit
            $product = Product::create($data);

            // Cr√©ation du mouvement de stock
            Stock::create([
                'date' => now()->toDateString(),
                'initial_stock' => 0,
                'label' => 'Ajout du produit ' . $product->name,
                'quantity' => $data['quantity'],
                'final_stock' => $data['quantity'],
                'product_id' => $product->id,
                'product_name' => $product->name,
                'is_depositable' => $data['is_depositable'],
                'deposit_price' => $data['deposit_price'],
                'filling_price' => $data['filling_price'],
                'sale_id' => null,
                'seller_name' => null,
            ]);

            // üîπ Si le produit est consignable ‚Üí cr√©ation du d√©p√¥t et de l‚Äôhistorique
            if ($data['is_depositable']) {
                $deposit = \App\Models\Deposit::create([
                    'product_id' => $product->id,
                    'product_name' => $product->name,
                    'quantity' => 0,
                ]);

                \App\Models\StockDeposit::create([
                    'product_id' => $product->id,
                    'initial_stock' => 0,
                    'quantity' => 0,
                    'final_stock' => 0,
                    'comment' => 'Cr√©ation du produit ' . $product->name,
                ]);
            }

            // Cr√©ation d‚Äôune notification
            Notification::create([
                'description' => 'Produit ' . $data['name'] . ' ajout√© avec succ√®s. Quantit√© : ' . $data['quantity'] . '.',
            ]);

            return response()->json(['message' => 'Produit ajout√© avec succ√®s.'], 201);
        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Erreur lors de la cr√©ation du produit.',
                'details' => $e->getMessage()
            ], 500);
        }
    }





    public function updatePrices(Request $request, $id)
    {
        // Validation des donn√©es re√ßues
        $validated = $request->validate([
            'price_detail' => 'required|numeric|min:0',
            'price_semi_bulk' => 'required|numeric|min:0',
            'price_bulk' => 'required|numeric|min:0',
            'deposit_price' => 'nullable|numeric|min:0',
        ]);

        // Trouver le produit
        $product = Product::findOrFail($id);

        // R√©cup√©ration des anciens prix
        $oldDetail = $product->price_detail;
        $oldSemiBulk = $product->price_semi_bulk;
        $oldBulk = $product->price_bulk;
        $oldDeposit = $product->deposit_price;

        // Mise √† jour des prix
        $product->price_detail = $validated['price_detail'];
        $product->price_semi_bulk = $validated['price_semi_bulk'];
        $product->price_bulk = $validated['price_bulk'];

        // Mise √† jour du prix de consignation si le produit est consignable
        if ($product->is_depositable && isset($validated['deposit_price'])) {
            $product->deposit_price = $validated['deposit_price'];
        }

        // Construction du message de notification
        $messages = [];

        if ($oldDetail != $validated['price_detail']) {
            $messages[] = 'd√©tail: ' . $oldDetail . ' ‚Üí ' . $validated['price_detail'];
        }
        if ($oldSemiBulk != $validated['price_semi_bulk']) {
            $messages[] = 'semi-gros: ' . $oldSemiBulk . ' ‚Üí ' . $validated['price_semi_bulk'];
        }
        if ($oldBulk != $validated['price_bulk']) {
            $messages[] = 'gros: ' . $oldBulk . ' ‚Üí ' . $validated['price_bulk'];
        }
        if ($product->is_depositable && $oldDeposit != $product->deposit_price) {
            $messages[] = 'consignation: ' . $oldDeposit . ' ‚Üí ' . $product->deposit_price;
        }

        $product->save();

        // Cr√©er une notification seulement si au moins un prix a chang√©
        if (!empty($messages)) {
            $label = 'Mise √† jour des prix pour le produit "' . $product->name . '": ' . implode('; ', $messages);
            Notification::create([
                'description' => $label,
            ]);
        }

        return response()->json([
            'message' => 'Prix mis √† jour avec succ√®s',
            'product' => $product
        ], 200);
    }



    public function updateStock(Request $request, $id)
    {
        $request->validate([
            'quantity' => [
                'required',
                'numeric',
                'regex:/^\d+(\.\d{1,2})?$/',
                'min:0.01',
            ],
        ]);

        $product = Product::findOrFail($id);

        $initial_quantity = $product->quantity;
        $added_quantity = $request->input('quantity');

        $product->quantity += $added_quantity;
        $product->save();

        $label = "Mise √† jour du stock de {$product->name}. Quantit√© ajout√©e : {$added_quantity}.";

        Stock::create([
            'date' => now()->toDateString(),
            'initial_stock' => $initial_quantity,
            'label' => $label,
            'quantity' => $added_quantity,
            'final_stock' => $product->quantity,
            'product_id' => $product->id,
            'product_name' => $product->name,
            'sale_id' => null,
            'seller_name' => null,
        ]);

        Notification::create([
            'description' => $label,
        ]);

        return response()->json(['message' => 'Stock ajout√© avec succ√®s.']);
    }


    public function getAccountingData($id)
    {
        $product = Product::findOrFail($id);

        // R√©cup√©rer les ventes 'done' pour ce produit
        $doneSaleIds = \App\Models\Sale::where('status', 'done')->pluck('id');

        $sales = \App\Models\SaleProduct::where('product_id', $id)
            ->whereIn('sale_id', $doneSaleIds)
            ->get();

        $totalQuantity = $sales->sum('quantity');

        $totalRevenue = $sales->sum(function ($sale) {
            return $sale->quantity * $sale->price;
        });

        $totalCost = $product->purchase_price * $totalQuantity;

        $profit = $totalRevenue - $totalCost;

        $salesDetails = $sales->map(function ($sale) use ($product) {
            return [
                'id' => $sale->id,
                'quantity' => $sale->quantity,
                'price' => $sale->price,
                'created_at' => $sale->created_at->toDateTimeString(),
                'total_sale' => $sale->quantity * $sale->price,
                'total_cost' => $product->purchase_price * $sale->quantity,
                'profit' => $sale->quantity * $sale->price - $product->purchase_price * $sale->quantity,
            ];
        });

        return response()->json([
            'total_quantity_sold' => $totalQuantity,
            'total_revenue' => $totalRevenue,
            'total_cost' => $totalCost,
            'profit' => $profit,
            'sales_details' => $salesDetails,
        ]);
    }



    public function revertAddStock(Request $request)
    {
        // 1. Validation de l'ID du produit
        $validated = $request->validate([
            'product_id' => 'required|integer|exists:products,id',
        ]);

        DB::beginTransaction();

        try {
            // 2. R√©cup√©rer le produit concern√©
            $product = Product::findOrFail($validated['product_id']);

            // 3. Trouver la derni√®re op√©ration d'ajout de stock pour ce produit
            $lastStockEntry = Stock::where('product_id', $product->id)
                ->where('label', 'like', 'Mise √† jour du stock de %')
                ->where('quantity', '>', 0) // Pour s'assurer que c'√©tait bien un ajout
                ->latest()
                ->first();

            // 4. V√©rifier si une op√©ration √† annuler a √©t√© trouv√©e
            if (!$lastStockEntry) {
                DB::rollBack();
                return response()->json([
                    'error' => 'Op√©ration non trouv√©e',
                    'message' => 'Aucune op√©ration d\'ajout de stock r√©cente n\'a √©t√© trouv√©e pour ce produit.',
                ], 404);
            }

            // 5. V√©rifier si le stock actuel est suffisant
            if ($product->quantity < $lastStockEntry->quantity) {
                DB::rollBack();
                return response()->json([
                    'error' => 'Stock insuffisant',
                    'message' => "Impossible d'annuler l'op√©ration. Le stock actuel est inf√©rieur √† la quantit√© √† retirer."
                ], 409);
            }

            // 6. Mettre √† jour le stock du produit
            $initialQuantity = $product->quantity;
            $product->quantity -= $lastStockEntry->quantity;
            $product->save();

            // 7. Enregistrer une nouvelle op√©ration dans la table `stocks`
            $label = "Annulation de l'op√©ration de mise √† jour du stock.";
            Stock::create([
                'date' => Carbon::now()->toDateString(),
                'initial_stock' => $initialQuantity,
                'label' => $label,
                'quantity' => -$lastStockEntry->quantity, // Quantit√© n√©gative pour indiquer le retrait
                'final_stock' => $product->quantity,
                'product_id' => $product->id,
                'product_name' => $product->name,
                'sale_id' => null,
                'seller_name' => null,
            ]);

            // 8. Enregistrer une notification
            Notification::create([
                'description' => "Op√©ration annul√©e pour le produit '{$product->name}'. Quantit√© retir√©e : {$lastStockEntry->quantity}.",
            ]);

            DB::commit();

            return response()->json([
                'message' => 'Op√©ration d\'ajout de stock annul√©e avec succ√®s.',
                'product' => $product,
            ], 200);
        } catch (\Exception $e) {
            DB::rollBack();
            return response()->json([
                'error' => '√âchec de l\'annulation de l\'op√©ration.',
                'message' => $e->getMessage(),
            ], 500);
        }
    }

    public function destroy($id, Request $request)
    {
        try {
            $product = Product::findOrFail($id);
            $product->delete();

            Notification::create([
                'description' => 'Produit ' . $product->name . ' supprim√©.',
            ]);

            return response()->json([
                'status' => 'success',
                'message' => 'Produit supprim√© avec succ√®s.'
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'status' => 'error',
                'message' => 'Erreur de suppression: ' . $e->getMessage()
            ], 500);
        }
    }
}
